//! {{project_name}} - ERC-721 NFT Contract
//!
//! A complete ERC-721 non-fungible token implementation using TAKO storage containers.

use tako_macros::*;
use tako_storage::prelude::*;

type Address = [u8; 32];
type TokenId = u128;

/// ERC-721 NFT Contract
///
/// Features:
/// - Standard ERC-721 operations (mint, transfer, approve)
/// - Token metadata with URI support
/// - Operator approvals for managing all tokens
/// - Safe transfer functionality
pub struct {{project_name}} {
    // Contract metadata
    name: Value<String>,
    symbol: Value<String>,

    // Total supply
    total_supply: Value<u128>,

    // Token ownership: token_id => owner
    owners: Mapping<TokenId, Address>,

    // Owner balances: owner => count
    balances: Mapping<Address, u128>,

    // Token approvals: token_id => approved_address
    token_approvals: Mapping<TokenId, Address>,

    // Operator approvals: (owner, operator) => approved
    operator_approvals: Mapping<(Address, Address), bool>,

    // Token metadata URIs: token_id => uri
    token_uris: Mapping<TokenId, String>,
}

impl {{project_name}} {
    /// Create a new ERC-721 contract
    pub fn new(name: &str, symbol: &str) -> Self {
        let mut contract = Self {
            name: Value::new("name"),
            symbol: Value::new("symbol"),
            total_supply: Value::new("total_supply"),
            owners: Mapping::new("owners"),
            balances: Mapping::new("balances"),
            token_approvals: Mapping::new("token_approvals"),
            operator_approvals: Mapping::new("operator_approvals"),
            token_uris: Mapping::new("token_uris"),
        };

        contract.name.set(name.to_string()).unwrap();
        contract.symbol.set(symbol.to_string()).unwrap();
        contract.total_supply.set(0).unwrap();

        contract
    }

    // ========== Metadata ==========

    /// Get collection name
    pub fn name(&self) -> StorageResult<String> {
        self.name.get()
    }

    /// Get collection symbol
    pub fn symbol(&self) -> StorageResult<String> {
        self.symbol.get()
    }

    /// Get total supply of tokens
    pub fn total_supply(&self) -> u128 {
        self.total_supply.get_or_default()
    }

    /// Get token metadata URI
    pub fn token_uri(&self, token_id: TokenId) -> StorageResult<String> {
        require!(self.exists(token_id), "Token does not exist");
        self.token_uris.get(&token_id)
    }

    // ========== Balance & Ownership ==========

    /// Get number of tokens owned by address
    pub fn balance_of(&self, owner: &Address) -> u128 {
        self.balances.get_or_default(owner)
    }

    /// Get owner of a token
    pub fn owner_of(&self, token_id: TokenId) -> StorageResult<Address> {
        self.owners.get(&token_id)
    }

    /// Check if token exists
    pub fn exists(&self, token_id: TokenId) -> bool {
        self.owners.contains(&token_id)
    }

    // ========== Approval ==========

    /// Approve an address to transfer a specific token
    pub fn approve(&mut self, to: &Address, token_id: TokenId) -> StorageResult<()> {
        let owner = self.owner_of(token_id)?;
        require!(*to != owner, "Approval to current owner");

        self.token_approvals.set(&token_id, *to)?;
        Ok(())
    }

    /// Get approved address for a token
    pub fn get_approved(&self, token_id: TokenId) -> StorageResult<Address> {
        require!(self.exists(token_id), "Token does not exist");
        self.token_approvals.get(&token_id)
    }

    /// Approve or revoke operator for all tokens
    pub fn set_approval_for_all(
        &mut self,
        owner: &Address,
        operator: &Address,
        approved: bool,
    ) -> StorageResult<()> {
        require!(*owner != *operator, "Cannot approve self");
        self.operator_approvals.set(&(*owner, *operator), approved)?;
        Ok(())
    }

    /// Check if operator is approved for all tokens
    pub fn is_approved_for_all(&self, owner: &Address, operator: &Address) -> bool {
        self.operator_approvals.get_or_default(&(*owner, *operator))
    }

    // ========== Transfer ==========

    /// Transfer token to another address
    pub fn transfer_from(
        &mut self,
        from: &Address,
        to: &Address,
        token_id: TokenId,
    ) -> StorageResult<()> {
        require!(*to != [0u8; 32], "Transfer to zero address");

        let owner = self.owner_of(token_id)?;
        require!(*from == owner, "Transfer from incorrect owner");

        // Clear approvals
        self.token_approvals.remove(&token_id)?;

        // Update balances
        self.balances.decrement(from, 1)?;
        self.balances.increment(to, 1)?;

        // Transfer ownership
        self.owners.set(&token_id, *to)?;

        Ok(())
    }

    /// Safe transfer with receiver validation
    pub fn safe_transfer_from(
        &mut self,
        from: &Address,
        to: &Address,
        token_id: TokenId,
    ) -> StorageResult<()> {
        self.transfer_from(from, to, token_id)?;
        // TODO: Add onERC721Received callback check
        Ok(())
    }

    // ========== Minting & Burning ==========

    /// Mint a new token
    pub fn mint(&mut self, to: &Address, token_id: TokenId, uri: String) -> StorageResult<()> {
        require!(*to != [0u8; 32], "Mint to zero address");
        require!(!self.exists(token_id), "Token already minted");

        // Update state
        self.balances.increment(to, 1)?;
        self.owners.set(&token_id, *to)?;
        self.token_uris.set(&token_id, uri)?;
        self.total_supply.increment(1)?;

        Ok(())
    }

    /// Burn a token
    pub fn burn(&mut self, token_id: TokenId) -> StorageResult<()> {
        let owner = self.owner_of(token_id)?;

        // Clear approvals
        self.token_approvals.remove(&token_id)?;

        // Update state
        self.balances.decrement(&owner, 1)?;
        self.owners.remove(&token_id)?;
        self.token_uris.remove(&token_id)?;
        self.total_supply.decrement(1)?;

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn alice() -> Address {
        [1u8; 32]
    }

    fn bob() -> Address {
        [2u8; 32]
    }

    fn carol() -> Address {
        [3u8; 32]
    }

    #[test]
    fn test_metadata() {
        let nft = {{project_name}}::new("My NFT", "MNFT");
        assert_eq!(nft.name().unwrap(), "My NFT");
        assert_eq!(nft.symbol().unwrap(), "MNFT");
        assert_eq!(nft.total_supply(), 0);
    }

    #[test]
    fn test_mint() {
        let mut nft = {{project_name}}::new("Test NFT", "TEST");

        nft.mint(&alice(), 1, "https://example.com/1".to_string())
            .unwrap();

        assert_eq!(nft.total_supply(), 1);
        assert_eq!(nft.owner_of(1).unwrap(), alice());
        assert_eq!(nft.balance_of(&alice()), 1);
        assert_eq!(nft.token_uri(1).unwrap(), "https://example.com/1");
    }

    #[test]
    fn test_transfer() {
        let mut nft = {{project_name}}::new("Test NFT", "TEST");

        nft.mint(&alice(), 1, "https://example.com/1".to_string())
            .unwrap();
        nft.transfer_from(&alice(), &bob(), 1).unwrap();

        assert_eq!(nft.owner_of(1).unwrap(), bob());
        assert_eq!(nft.balance_of(&alice()), 0);
        assert_eq!(nft.balance_of(&bob()), 1);
    }

    #[test]
    fn test_approval() {
        let mut nft = {{project_name}}::new("Test NFT", "TEST");

        nft.mint(&alice(), 1, "https://example.com/1".to_string())
            .unwrap();
        nft.approve(&bob(), 1).unwrap();

        assert_eq!(nft.get_approved(1).unwrap(), bob());
    }

    #[test]
    fn test_operator_approval() {
        let mut nft = {{project_name}}::new("Test NFT", "TEST");

        nft.set_approval_for_all(&alice(), &bob(), true).unwrap();
        assert!(nft.is_approved_for_all(&alice(), &bob()));

        nft.set_approval_for_all(&alice(), &bob(), false).unwrap();
        assert!(!nft.is_approved_for_all(&alice(), &bob()));
    }

    #[test]
    fn test_burn() {
        let mut nft = {{project_name}}::new("Test NFT", "TEST");

        nft.mint(&alice(), 1, "https://example.com/1".to_string())
            .unwrap();
        assert_eq!(nft.total_supply(), 1);

        nft.burn(1).unwrap();
        assert_eq!(nft.total_supply(), 0);
        assert!(!nft.exists(1));
        assert_eq!(nft.balance_of(&alice()), 0);
    }

    #[test]
    fn test_multiple_tokens() {
        let mut nft = {{project_name}}::new("Test NFT", "TEST");

        nft.mint(&alice(), 1, "https://example.com/1".to_string())
            .unwrap();
        nft.mint(&alice(), 2, "https://example.com/2".to_string())
            .unwrap();
        nft.mint(&bob(), 3, "https://example.com/3".to_string())
            .unwrap();

        assert_eq!(nft.total_supply(), 3);
        assert_eq!(nft.balance_of(&alice()), 2);
        assert_eq!(nft.balance_of(&bob()), 1);
    }

    #[test]
    fn test_transfer_clears_approval() {
        let mut nft = {{project_name}}::new("Test NFT", "TEST");

        nft.mint(&alice(), 1, "https://example.com/1".to_string())
            .unwrap();
        nft.approve(&bob(), 1).unwrap();

        nft.transfer_from(&alice(), &carol(), 1).unwrap();

        // Approval should be cleared after transfer
        assert!(nft.get_approved(1).is_err());
    }
}
